#!/usr/bin/env python3
"""
Enhanced Pi Script for ESP32 Wireless Button System
Works with the ESP32 receiver to play sound effects based on button presses
"""

import os, glob, time, random, sys, serial, json, threading
from datetime import datetime

# Configuration
BAUD = 115200
SERIAL = os.getenv("MATT_SFX_SERIAL", "/dev/ttyACM0")
READY_PIN = 23
USB_LED_PIN = 24  # New LED for USB drive status
READY_ACTIVE_LOW = True
USB_LED_ACTIVE_LOW = True  # USB LED also active-low
MIX_FREQ = 44100
MIX_BUF = 256
RESCAN_SEC = 1.0
IDLE_SHUTOFF_SEC = 1.0
LOG_FILE = "/home/pi/WRB/button_log.txt"

# Hold configuration
HOLD_ENABLED = True  # Set to False to disable hold functionality
HOLD_DELAY_MS = 1000  # Milliseconds to hold button before triggering hold sound

# ESP32 Message Types (matching your ESP32 code)
MSG_PING = 0xA0
MSG_ACK = 0xA1
MSG_BTN = 0xB0
MSG_BTN_HOLD = 0xB1

# --- LED (PWM for status LED, simple on/off for USB LED) ---
try:
    from gpiozero import LED, PWMLED
    # Status LED with PWM for brightness control
    led = PWMLED(READY_PIN, active_high=(not READY_ACTIVE_LOW))
    # USB LED simple on/off
    usb_led = LED(USB_LED_PIN, active_high=(not USB_LED_ACTIVE_LOW))
    LED_AVAILABLE = True
    USB_LED_AVAILABLE = True
except ImportError:
    print("[WRB] Warning: gpiozero not available, LED disabled")
    LED_AVAILABLE = False
    USB_LED_AVAILABLE = False
except Exception as e:
    print(f"[WRB] Warning: LED initialization failed: {e}")
    LED_AVAILABLE = False
    USB_LED_AVAILABLE = False

def log_event(message):
    """Log events to file with timestamp"""
    try:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(LOG_FILE, "a") as f:
            f.write(f"{timestamp}: {message}\n")
    except:
        pass  # Don't fail if logging fails

def usb_mount_dirs():
    """Find mounted USB drives"""
    base = "/media"
    if not os.path.isdir(base):
        return []
    
    mounts = []
    for d in sorted(os.listdir(base)):
        path = os.path.join(base, d)
        if os.path.isdir(path) and os.path.ismount(path):
            mounts.append(path)
    return mounts

def update_usb_led(mounts):
    """Update USB LED based on mount status"""
    if not USB_LED_AVAILABLE:
        return
    
    try:
        if mounts:
            usb_led.off()  # USB drive is mounted (active-low: off = LED on)
        else:
            usb_led.on()   # No USB drive mounted (active-low: on = LED off)
    except Exception as e:
        print(f"[WRB] USB LED control failed: {e}", flush=True)

def pick_source():
    """Find sound files from USB or local storage"""
    # Check USB drives first
    mounts = usb_mount_dirs()
    update_usb_led(mounts)  # Update USB LED status
    
    for mnt in mounts:
        B1 = sorted(glob.glob(os.path.join(mnt, "button1*.wav")))
        B2 = sorted(glob.glob(os.path.join(mnt, "button2*.wav")))
        H1 = sorted(glob.glob(os.path.join(mnt, "hold1*.wav")))
        H2 = sorted(glob.glob(os.path.join(mnt, "hold2*.wav")))
        if B1 or B2 or H1 or H2:
            blink_usb_led()  # Blink to indicate USB drive with sound files
            return (f"USB:{mnt}", B1[:1], B2, H1[:1], H2)
    
    # Fall back to local storage
    local = os.path.expanduser("~/WRB")
    os.makedirs(local, exist_ok=True)
    B1 = sorted(glob.glob(os.path.join(local, "button1*.wav")))
    B2 = sorted(glob.glob(os.path.join(local, "button2*.wav")))
    H1 = sorted(glob.glob(os.path.join(local, "hold1*.wav")))
    H2 = sorted(glob.glob(os.path.join(local, "hold2*.wav")))
    return ("LOCAL", B1[:1], B2, H1[:1], H2)

def classify_esp32_message(line):
    """
    Parse ESP32 serial messages and classify button presses
    Handles both old format (R/W) and new ESP32 format
    """
    line = line.strip()
    
    # Try to parse as ESP32 message first
    try:
        # Look for ESP32 button messages: "RX: BTN1 from MAC" or "RX: BTN2 from MAC"
        if "RX: BTN" in line:
            if "BTN1 HOLD" in line:
                return 'RH', line  # Button 1 Hold
            elif "BTN2 HOLD" in line:
                return 'WH', line  # Button 2 Hold
            elif "BTN1" in line:
                return 'B1', line  # Button 1 = Button 1
            elif "BTN2" in line:
                return 'B2', line  # Button 2 = Button 2
        elif "Authorized transmitter connected" in line:
            return 'CONNECT', line
        elif "Status:" in line:
            return 'STATUS', line
        elif "Rejected message from unauthorized MAC" in line:
            return 'SECURITY', line
        elif "Receiver starting" in line:
            return 'STARTUP', line
        elif "Receiver ready" in line:
            return 'READY', line
        elif "ESP-NOW init failed" in line:
            return 'ERROR', line
    except:
        pass
    
    # Fall back to old format parsing
    u = line.upper()
    if u == "R" or "BTN1" in u or "BTN_R" in u:
        return 'B1', line
    if u == "W" or "BTN2" in u or "BTN_W" in u:
        return 'B2', line
    
    return None, line

# --- Audio System ---
_mixer_ready = False
_last_play = 0
_button1_paths = []
_button2_paths = []
_hold1_paths = []
_hold2_paths = []

def set_paths(B1, B2, H1, H2):
    """Set audio file paths"""
    global _button1_paths, _button2_paths, _hold1_paths, _hold2_paths
    _button1_paths, _button2_paths, _hold1_paths, _hold2_paths = B1, B2, H1, H2

def ensure_mixer():
    """Initialize pygame mixer"""
    global _mixer_ready
    if _mixer_ready:
        return
    
    try:
        import pygame
        for i in range(8):
            try:
                pygame.mixer.init(frequency=MIX_FREQ, size=-16, channels=4, buffer=MIX_BUF)
                _mixer_ready = True
                print("[WRB] audio: mixer ready (4 channels)", flush=True)
                log_event("Audio mixer initialized with 4 channels")
                return
            except Exception as e:
                print(f"[WRB] audio init retry {i+1}: {e}", flush=True)
                time.sleep(0.2)
        raise SystemExit("audio init failed")
    except ImportError:
        print("[WRB] Error: pygame not installed. Install with: pip3 install pygame")
        raise SystemExit("pygame not available")

def shutdown_mixer_if_idle():
    """Close mixer if idle to save resources"""
    global _mixer_ready
    if not _mixer_ready:
        return
    
    try:
        import pygame
        if (time.time() - _last_play) > IDLE_SHUTOFF_SEC and not pygame.mixer.get_busy():
            pygame.mixer.quit()
            _mixer_ready = False
            print("[WRB] audio: mixer closed (idle)", flush=True)
    except:
        pass

def play_button1():
    """Play button 1 sound effect"""
    global _last_play
    if not _button1_paths:
        print("[WRB] BUTTON1 (no file)", flush=True)
        return
    
    ensure_mixer()
    try:
        import pygame
        s = pygame.mixer.Sound(_button1_paths[0])
        pygame.mixer.Channel(0).play(s)
        _last_play = time.time()
        log_event(f"Played BUTTON1 sound: {_button1_paths[0]}")
    except Exception as e:
        print(f"[WRB] Error playing button1 sound: {e}", flush=True)

def play_button2():
    """Play button 2 sound effect"""
    global _last_play
    if not _button2_paths:
        print("[WRB] BUTTON2 (no files)", flush=True)
        return
    
    ensure_mixer()
    try:
        import pygame
        sound_file = random.choice(_button2_paths)
        s = pygame.mixer.Sound(sound_file)
        pygame.mixer.Channel(1).play(s)
        _last_play = time.time()
        log_event(f"Played BUTTON2 sound: {sound_file}")
    except Exception as e:
        print(f"[WRB] Error playing button2 sound: {e}", flush=True)

def play_hold1():
    """Play button 1 hold sound effect"""
    global _last_play
    if not _hold1_paths:
        print("[WRB] HOLD1 (no file)", flush=True)
        return
    
    ensure_mixer()
    try:
        import pygame
        s = pygame.mixer.Sound(_hold1_paths[0])
        pygame.mixer.Channel(2).play(s)  # Use channel 2 for hold sounds
        _last_play = time.time()
        log_event(f"Played HOLD1 sound: {_hold1_paths[0]}")
    except Exception as e:
        print(f"[WRB] Error playing hold1 sound: {e}", flush=True)

def play_hold2():
    """Play button 2 hold sound effect"""
    global _last_play
    if not _hold2_paths:
        print("[WRB] HOLD2 (no files)", flush=True)
        return
    
    ensure_mixer()
    try:
        import pygame
        sound_file = random.choice(_hold2_paths)
        s = pygame.mixer.Sound(sound_file)
        pygame.mixer.Channel(3).play(s)  # Use channel 3 for hold sounds
        _last_play = time.time()
        log_event(f"Played HOLD2 sound: {sound_file}")
    except Exception as e:
        print(f"[WRB] Error playing hold2 sound: {e}", flush=True)

def blink_led():
    """Blink the ready LED at full brightness"""
    if not LED_AVAILABLE:
        return
    
    try:
        led.value = 1.0  # Full brightness (100%)
        time.sleep(0.04)
        led.value = 0.5  # Back to 50% brightness
    except:
        pass

def blink_usb_led():
    """Blink the USB LED to indicate USB drive activity"""
    if not USB_LED_AVAILABLE:
        return
    
    try:
        usb_led.on()   # Turn LED off (active-low)
        time.sleep(0.1)
        usb_led.off()  # Turn LED on (active-low)
    except:
        pass

def wait_serial():
    """Wait for ESP32 serial connection"""
    print("[WRB] waiting for ESP32 serial connection...", flush=True)
    prefs = [SERIAL, "/dev/ttyACM0", "/dev/ttyACM1", "/dev/ttyUSB0", "/dev/ttyUSB1", "/dev/serial0", "/dev/ttyAMA0", "/dev/ttyS0"]
    
    while True:
        for p in prefs:
            try:
                ser = serial.Serial(p, BAUD, timeout=0.1)
                print(f"[WRB] Connected to ESP32 on {p}", flush=True)
                log_event(f"Connected to ESP32 on {p}")
                return ser
            except:
                pass
        time.sleep(0.3)

def main():
    """Main function"""
    if LED_AVAILABLE:
        led.value = 0.0  # OFF until ready
    if USB_LED_AVAILABLE:
        usb_led.off()  # USB LED OFF initially
    
    print("[WRB] ESP32 Wireless Button System - Enhanced Pi Script", flush=True)
    log_event("Pi script started")
    
    # Initialize audio source
    tag, B1, B2, H1, H2 = pick_source()
    set_paths(B1, B2, H1, H2)
    print(f"[WRB] source={tag} button1={B1[:1]} button2s={len(B2)} hold1={H1[:1]} hold2s={len(H2)}", flush=True)
    log_event(f"Audio source: {tag}, Button1 sounds: {len(B1)}, Button2 sounds: {len(B2)}, Hold1 sounds: {len(H1)}, Hold2 sounds: {len(H2)}")
    
    # Connect to ESP32
    ser = wait_serial()
    
    # Ready
    if LED_AVAILABLE:
        led.value = 0.5  # 50% brightness when ready
    print("[WRB] READY - Waiting for ESP32 button presses", flush=True)
    log_event("System ready")
    
    last_scan = time.time()
    connection_status = "connected"
    
    while True:
        # Hot-swap audio files
        if time.time() - last_scan > RESCAN_SEC:
            ntag, nB1, nB2, nH1, nH2 = pick_source()
            if (ntag != tag) or (nB1 != B1) or (nB2 != B2) or (nH1 != H1) or (nH2 != H2):
                tag, B1, B2, H1, H2 = ntag, nB1, nB2, nH1, nH2
                set_paths(B1, B2, H1, H2)
                print(f"[WRB] reloaded: source={tag} button1={B1[:1]} button2s={len(B2)} hold1={H1[:1]} hold2s={len(H2)}", flush=True)
                log_event(f"Audio files reloaded: {tag}")
            last_scan = time.time()
        
        # Read serial from ESP32
        try:
            line = ser.readline().decode(errors="ignore")
        except Exception as e:
            if connection_status == "connected":
                print(f"[WRB] Serial error: {e}", flush=True)
                log_event(f"Serial error: {e}")
                connection_status = "error"
            time.sleep(0.05)
            continue
        
        if not line:
            shutdown_mixer_if_idle()
            continue
        
        # Reset connection status if we're getting data
        if connection_status != "connected":
            connection_status = "connected"
            print("[WRB] Serial connection restored", flush=True)
            log_event("Serial connection restored")
        
        # Parse and handle ESP32 messages
        msg_type, full_line = classify_esp32_message(line)
        
        if msg_type == 'B1':
            print("[WRB] Button 1 pressed", flush=True)
            play_button1()
            blink_led()
            log_event("Button 1 pressed")
            
        elif msg_type == 'B2':
            print("[WRB] Button 2 pressed", flush=True)
            play_button2()
            blink_led()
            log_event("Button 2 pressed")
            
        elif msg_type == 'RH':
            print("[WRB] Button 1 held", flush=True)
            play_hold1()
            blink_led()
            log_event("Button 1 held")
            
        elif msg_type == 'WH':
            print("[WRB] Button 2 held", flush=True)
            play_hold2()
            blink_led()
            log_event("Button 2 held")
            
        elif msg_type == 'CONNECT':
            print(f"[WRB] ESP32: {full_line}", flush=True)
            log_event(f"ESP32: {full_line}")
            
        elif msg_type == 'STATUS':
            print(f"[WRB] ESP32 Status: {full_line}", flush=True)
            
        elif msg_type == 'SECURITY':
            print(f"[WRB] Security Alert: {full_line}", flush=True)
            log_event(f"Security: {full_line}")
            
        elif msg_type == 'STARTUP':
            print(f"[WRB] ESP32: {full_line}", flush=True)
            log_event(f"ESP32: {full_line}")
            
        elif msg_type == 'READY':
            print(f"[WRB] ESP32: {full_line}", flush=True)
            log_event(f"ESP32: {full_line}")
            
        elif msg_type == 'ERROR':
            print(f"[WRB] ESP32 Error: {full_line}", flush=True)
            log_event(f"ESP32 Error: {full_line}")
            
        elif full_line.strip():  # Only log non-empty lines
            print(f"[WRB] ESP32: {full_line}", flush=True)
        
        shutdown_mixer_if_idle()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[WRB] Shutting down...", flush=True)
        log_event("Script stopped by user")
        if LED_AVAILABLE:
            led.value = 0.0  # Turn off status LED
        if USB_LED_AVAILABLE:
            usb_led.off()
    except Exception as e:
        print(f"[WRB] Fatal error: {e}", flush=True)
        log_event(f"Fatal error: {e}")
        if LED_AVAILABLE:
            led.value = 0.0  # Turn off status LED
        if USB_LED_AVAILABLE:
            usb_led.off()
        sys.exit(1)
