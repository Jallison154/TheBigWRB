#!/usr/bin/env python3
import os, glob, time, random, sys, serial
from gpiozero import LED, PWMLED

# Import configuration
try:
    from config import *
    print("[WRB] Loaded configuration from config.py", flush=True)
except ImportError:
    print("[WRB] config.py not found, using defaults", flush=True)
    # Default values if config.py not found
    BAUD=115200
    SERIAL=os.getenv("WRB_SERIAL","/dev/ttyACM0")
    READY_PIN=23
    READY_ACTIVE_LOW=True
    MIX_FREQ=44100
    MIX_BUF=512
    RESCAN_SEC=1.0

# Audio device (your USB card is card0)
os.environ.setdefault("SDL_AUDIODRIVER","alsa")
os.environ.setdefault("AUDIODEV","plughw:0,0")

print(f"[WRB] Configuration: BAUD={BAUD}, SERIAL={SERIAL}, READY_PIN={READY_PIN}", flush=True)

def usb_mount_dirs():
    base="/media"
    return [os.path.join(base,d) for d in sorted(os.listdir(base)) 
            if os.path.isdir(os.path.join(base,d)) and os.path.ismount(os.path.join(base,d))] if os.path.isdir(base) else []

def pick_source():
    # Prefer USB with files; fall back to local
    for mnt in usb_mount_dirs():
        B1=sorted(glob.glob(os.path.join(mnt,"button1*.wav")))
        B2=sorted(glob.glob(os.path.join(mnt,"button2*.wav")))
        H1=sorted(glob.glob(os.path.join(mnt,"hold1*.wav")))
        H2=sorted(glob.glob(os.path.join(mnt,"hold2*.wav")))
        if B1 or B2 or H1 or H2:
            return (f"USB:{mnt}", mnt, B1[:1], B2, H1[:1], H2)
    local=os.path.expanduser("~/WRB/sounds"); os.makedirs(local, exist_ok=True)
    B1=sorted(glob.glob(os.path.join(local,"button1*.wav")))
    B2=sorted(glob.glob(os.path.join(local,"button2*.wav")))
    H1=sorted(glob.glob(os.path.join(local,"hold1*.wav")))
    H2=sorted(glob.glob(os.path.join(local,"hold2*.wav")))
    return ("LOCAL", local, B1[:1], B2, H1[:1], H2)

def load_sounds(B1, B2, H1, H2):
    """Load sound file paths - actual Sound objects created on-demand"""
    # Just return the file paths, not pygame Sound objects
    button1 = B1[0] if B1 and os.path.exists(B1[0]) else None
    button2 = [p for p in B2 if os.path.exists(p)]
    hold1 = H1[0] if H1 and os.path.exists(H1[0]) else None
    hold2 = [p for p in H2 if os.path.exists(p)]
    return button1, button2, hold1, hold2

def play_sound(sound_path, channel=0):
    """Play a sound file on-demand with mixer initialization"""
    import pygame
    if not sound_path:
        return False
    
    if ensure_mixer():
        try:
            sound = pygame.mixer.Sound(sound_path)
            pygame.mixer.Channel(channel).play(sound)
            return True
        except Exception as e:
            print(f"[WRB] Playback failed: {e}", flush=True)
            return False
    return False

def play_random_sound(sound_paths, channel=1):
    """Play a random sound from a list of paths"""
    import pygame
    if not sound_paths:
        return False
    
    if ensure_mixer():
        try:
            sound_path = random.choice(sound_paths)
            sound = pygame.mixer.Sound(sound_path)
            pygame.mixer.Channel(channel).play(sound)
            return True
        except Exception as e:
            print(f"[WRB] Random playback failed: {e}", flush=True)
            return False
    return False

def classify(s):
    u=s.strip().upper()
    if "BTN1" in u and "HOLD" in u: return 'H1'
    if "BTN2" in u and "HOLD" in u: return 'H2'
    if "BTN1" in u: return 'B1'
    if "BTN2" in u: return 'B2'
    return None

def ensure_mixer():
    """On-demand mixer initialization - only opens audio when needed"""
    import pygame
    if not pygame.mixer.get_init():
        try:
            pygame.mixer.init(frequency=MIX_FREQ, size=-16, channels=2, buffer=256)
            pygame.mixer.set_num_channels(16)
            print("[WRB] audio: mixer opened on-demand", flush=True)
        except Exception as e:
            print(f"[WRB] audio init failed: {e}", flush=True)
            # Don't crash - continue without audio
            return False
    return True

def close_if_idle(last_play_time):
    """Close audio device after inactivity to prevent always streaming"""
    import pygame
    if pygame.mixer.get_init():
        time_since_last = time.time() - last_play_time
        if time_since_last > 1.0 and not pygame.mixer.get_busy():
            pygame.mixer.quit()
            print("[WRB] audio: mixer closed (idle)", flush=True)

def wait_serial():
    prefs=[SERIAL,"/dev/ttyACM0","/dev/ttyACM1","/dev/ttyUSB0","/dev/ttyUSB1","/dev/serial0","/dev/ttyAMA0","/dev/ttyS0"]
    print("[WRB] waiting for serialâ€¦", flush=True)
    while True:
        for p in prefs:
            try: return serial.Serial(p, BAUD, timeout=0.1)
            except: pass
        time.sleep(0.1)  # Reduced from 0.3 to 0.1 seconds

def breathing_led(led, duration=2.0, steps=20):
    """Breathing LED effect from 0 to 100% brightness"""
    import math
    for i in range(int(steps * 2)):  # 2 cycles
        # Create smooth breathing curve using sine wave
        brightness = (math.sin(i * math.pi / steps) + 1) / 2  # 0 to 1
        if READY_ACTIVE_LOW:
            # For active low LEDs, invert the brightness
            brightness = 1 - brightness
        led.value = brightness
        time.sleep(duration / (steps * 2))

def main():
    import pygame
    from gpiozero import PWMLED
    
    # Use PWMLED for brightness control instead of regular LED
    led = PWMLED(READY_PIN, active_high=(not READY_ACTIVE_LOW))
    
    print("[WRB] Starting up...", flush=True)
    
    # Quick breathing LED during startup (faster)
    breathing_led(led, duration=0.8, steps=8)
    
    print("[WRB] Loading sound files...", flush=True)
    src_tag, base, B1, B2, H1, H2 = pick_source()
    BUTTON1, BUTTON2, HOLD1, HOLD2 = load_sounds(B1, B2, H1, H2)
    print(f"[WRB] source={src_tag} button1={B1[:1]} button2={len(BUTTON2)} hold1={H1[:1]} hold2={len(HOLD2)}", flush=True)

    print("[WRB] Connecting to ESP32...", flush=True)
    ser=wait_serial()
    print(f"[WRB] serial: {ser.port}", flush=True)

    # Set LED to 25% brightness when ready
    if READY_ACTIVE_LOW:
        led.value = 0.75  # 25% brightness for active low
    else:
        led.value = 0.25  # 25% brightness for active high
    
    print("[WRB] READY - LED at 25% brightness (audio on-demand)", flush=True)
    last_scan=time.time()
    last_play_time=0  # Track when audio was last played

    while True:
        # Hot-swap USB/local
        if time.time()-last_scan > RESCAN_SEC:
            new_tag, new_base, nB1, nB2, nH1, nH2 = pick_source()
            if (new_tag != src_tag) or (nB1 != B1) or (nB2 != B2) or (nH1 != H1) or (nH2 != H2):
                for ch in range(0,15): pygame.mixer.Channel(ch).stop()
                BUTTON1, BUTTON2, HOLD1, HOLD2 = load_sounds(nB1, nB2, nH1, nH2)
                src_tag, base, B1, B2, H1, H2 = new_tag, new_base, nB1, nB2, nH1, nH2
                print(f"[WRB] reloaded: source={src_tag} button1={B1[:1]} button2={len(BUTTON2)} hold1={H1[:1]} hold2={len(HOLD2)}", flush=True)
            last_scan=time.time()

        try: line=ser.readline().decode(errors="ignore")
        except Exception: 
            # Check for idle audio shutdown
            close_if_idle(last_play_time)
            time.sleep(0.05)
            continue
        if not line: 
            # Check for idle audio shutdown
            close_if_idle(last_play_time)
            continue
            
        t=classify(line)
        if t=='B1':
            if play_sound(BUTTON1, channel=0): 
                last_play_time = time.time()
            print("[WRB] BUTTON1 (src=%s loaded=%s)"%(src_tag,bool(BUTTON1)), flush=True)
            try: 
                # Blink to 100% brightness
                led.value = 0.0 if READY_ACTIVE_LOW else 1.0
                time.sleep(0.1)
                # Return to 25% brightness
                led.value = 0.75 if READY_ACTIVE_LOW else 0.25
            except: pass
        elif t=='B2':
            if play_random_sound(BUTTON2, channel=1): 
                last_play_time = time.time()
            print("[WRB] BUTTON2 (src=%s loaded=%d)"%(src_tag,len(BUTTON2)), flush=True)
            try: 
                # Blink to 100% brightness
                led.value = 0.0 if READY_ACTIVE_LOW else 1.0
                time.sleep(0.1)
                # Return to 25% brightness
                led.value = 0.75 if READY_ACTIVE_LOW else 0.25
            except: pass
        elif t=='H1':
            if play_sound(HOLD1, channel=2): 
                last_play_time = time.time()
            print("[WRB] HOLD1 (src=%s loaded=%s)"%(src_tag,bool(HOLD1)), flush=True)
            try: 
                # Blink to 100% brightness
                led.value = 0.0 if READY_ACTIVE_LOW else 1.0
                time.sleep(0.1)
                # Return to 25% brightness
                led.value = 0.75 if READY_ACTIVE_LOW else 0.25
            except: pass
        elif t=='H2':
            if play_random_sound(HOLD2, channel=3): 
                last_play_time = time.time()
            print("[WRB] HOLD2 (src=%s loaded=%d)"%(src_tag,len(HOLD2)), flush=True)
            try: 
                # Blink to 100% brightness
                led.value = 0.0 if READY_ACTIVE_LOW else 1.0
                time.sleep(0.1)
                # Return to 25% brightness
                led.value = 0.75 if READY_ACTIVE_LOW else 0.25
            except: pass

if __name__=="__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("[WRB] Shutdown requested by user", flush=True)
        sys.exit(0)
    except Exception as e:
        print(f"[WRB] Fatal error: {e}", flush=True)
        # Exit with code 1 to trigger restart (but not if we've restarted too many times)
        sys.exit(1)