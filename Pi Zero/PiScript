#!/usr/bin/env python3
"""
WRB Pi Script - ESP32 Wireless Button System
Main script for handling ESP32 communication and audio playback
"""

import os
import sys
import time
import serial
import pygame
import glob
from datetime import datetime

# Configuration
BAUD = 115200
SERIAL_PORT = "/dev/ttyACM0"
READY_PIN = 23
MIX_FREQ = 44100
MIX_BUF = 512

# Try to import config
try:
    from config import *
    print("[WRB] Loaded configuration from config.py")
except ImportError:
    print("[WRB] config.py not found, using defaults")

# Initialize pygame mixer
pygame.mixer.pre_init(frequency=MIX_FREQ, size=-16, channels=2, buffer=MIX_BUF)
pygame.mixer.init()
print(f"[WRB] Audio initialized: {MIX_FREQ}Hz, buffer={MIX_BUF}")

# Sound file paths
SOUNDS_DIR = os.path.expanduser("~/WRB/sounds")
os.makedirs(SOUNDS_DIR, exist_ok=True)

def load_sounds():
    """Load sound files into memory"""
    sounds = {}
    
    # Find sound files
    button1_files = glob.glob(os.path.join(SOUNDS_DIR, "button1*.wav"))
    button2_files = glob.glob(os.path.join(SOUNDS_DIR, "button2*.wav"))
    hold1_files = glob.glob(os.path.join(SOUNDS_DIR, "hold1*.wav"))
    hold2_files = glob.glob(os.path.join(SOUNDS_DIR, "hold2*.wav"))
    
    # Load sounds
    if button1_files:
        sounds['button1'] = pygame.mixer.Sound(button1_files[0])
        print(f"[WRB] Loaded button1: {button1_files[0]}")
    
    if button2_files:
        sounds['button2'] = pygame.mixer.Sound(button2_files[0])
        print(f"[WRB] Loaded button2: {button2_files[0]}")
    
    if hold1_files:
        sounds['hold1'] = pygame.mixer.Sound(hold1_files[0])
        print(f"[WRB] Loaded hold1: {hold1_files[0]}")
    
    if hold2_files:
        sounds['hold2'] = pygame.mixer.Sound(hold2_files[0])
        print(f"[WRB] Loaded hold2: {hold2_files[0]}")
    
    return sounds

def play_sound(sounds, sound_name):
    """Play a sound if available"""
    if sound_name in sounds:
        try:
            sounds[sound_name].play()
            print(f"[WRB] Playing {sound_name}")
        except Exception as e:
            print(f"[WRB] Error playing {sound_name}: {e}")
    else:
        print(f"[WRB] Sound {sound_name} not available")

def connect_esp32():
    """Connect to ESP32 receiver"""
    try:
        ser = serial.Serial(SERIAL_PORT, BAUD, timeout=1)
        print(f"[WRB] Connected to ESP32 on {SERIAL_PORT}")
        return ser
    except Exception as e:
        print(f"[WRB] Failed to connect to ESP32: {e}")
        return None

def main():
    """Main application loop"""
    print("[WRB] Starting WRB Pi Script")
    print(f"[WRB] Configuration: BAUD={BAUD}, SERIAL={SERIAL_PORT}, READY_PIN={READY_PIN}")
    
    # Load sounds
    sounds = load_sounds()
    if not sounds:
        print("[WRB] No sound files found in ~/WRB/sounds/")
        print("[WRB] Please add button1*.wav, button2*.wav, hold1*.wav, hold2*.wav files")
    
    # Connect to ESP32
    ser = connect_esp32()
    if not ser:
        print("[WRB] ESP32 not connected, running in simulation mode")
        print("[WRB] Press Ctrl+C to exit")
        
        # Simulation mode - just wait
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\n[WRB] Exiting...")
            sys.exit(0)
    
    print("[WRB] Ready! Waiting for button presses...")
    
    # Main loop
    try:
        while True:
            if ser.in_waiting > 0:
                try:
                    data = ser.readline().decode('utf-8').strip()
                    if data:
                        print(f"[WRB] Received: {data}")
                        
                        # Parse button messages
                        if "BTN1" in data:
                            play_sound(sounds, 'button1')
                        elif "BTN2" in data:
                            play_sound(sounds, 'button2')
                        elif "HOLD1" in data:
                            play_sound(sounds, 'hold1')
                        elif "HOLD2" in data:
                            play_sound(sounds, 'hold2')
                        
                except Exception as e:
                    print(f"[WRB] Error reading serial: {e}")
            
            time.sleep(0.1)
            
    except KeyboardInterrupt:
        print("\n[WRB] Exiting...")
        if ser:
            ser.close()
        sys.exit(0)

if __name__ == "__main__":
    main()